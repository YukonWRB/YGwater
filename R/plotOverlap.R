#' Plot of overlapping years or portions thereof
#'
#' @description
#' `r lifecycle::badge('stable')`
#'
#' Generate plots of water level/flow, snow pillows, or other continuous data present in the local hydrometric database generated by package HydroMetDB for any given start/end day of year. Integrates return periods if requested.
#'
#' Notice: in many cases, you're better off using the Shiny app at [hydroApp()] to generate and export your plot. Read on if you need additional control over the final product.
#'
#' This function plots data from the local hydrometric database (maintained by the HydroMetDB package) and yields consistent-looking plots for continuous data. This function can only plot what's in the database. Plots will include bands representing the historic min, max, and 25th-75th percentiles based on the last year of data requested. If necessary for performance, data may be down-sampled to daily means: see details.
#'
#' @details
#' Superseded functions WRBfloods::levelPlot() and WRBfloods::flowPlot() can be used in the event that this function does not yield your desired graph, or if you cannot use the local database and must use data directly from the Water Survey of Canada.
#'
#' ## Down sampling of data
#' When requesting time periods where high-frequency (realtime) data is available, some of the data may be displayed as daily means instead to improve performance. Specifically, only day ranges of less than 60 days will have high-frequency data (61 days or more will be plotted with daily means). Additionally, daily means will be fetched once the number of high-frequency rows exceeds 20 000 after year specified under parameter `years` (this will plot up to two 60-day lines at 5 minute recording intervals). In all cases, high-frequency data will be fetched nearest to the specified `endDate`.
#'
#' ## Return periods:
#' Return periods generated using the "calculate" option are calculated using all available after applying the parameter `return_max_year`. Extreme values are isolated for each year and passed to [fasstr::compute_frequency_analysis()] using a Log Pearson Type 3 distribution and the method of moments to fit a curve to the distribution. Years (or rather periods within years; see below) missing more than the percentage of data specified in `allowed_missing` are excluded from consideration.
#'
#' As the time of year during which minimum or maximum values happen is variable and to prevent filtering out years that are missing irrelevant data (most rivers peak in spring, some peak in late summer, snow pack peaks in winter), the parameters return_months and allowed_missing should be carefully selected. This may require you to make a graph first to evaluate when the annual min/max of interest happens. Consider as well that you can ask for return periods specific for a month or season, such as return periods of minimum flows in September, or maximum flows in January. This also applies to levels or any other continuous parameter which this function can plot.
#'
#' If specifying the option "table", the function will attempt to find returns for the location within the package internal data. The returns contained there are from consultant work involving a detailed analysis of which data to keep/discard, as well as a human determination of the most appropriate distribution and curve fitting methods. The caveat here is that these tables are not necessarily up to date, that most locations have no calculated return periods, and that return periods only exist for water levels.
#'
#' @param location The location for which you want a plot.
#' @param parameter The parameter you wish to plot. The location:parameter combo must be in the local database.
#' @param record_rate The recording rate for the parameter and location to plot. In most cases there are not multiple recording rates for a location and parameter combo and you can leave this NULL. Otherwise NULL will default to the most frequent record rate, or set this as one of '< 1 day', '1 day', '1 week', '4 weeks', '1 month', 'year'.
#' @param startDay The start day of year for the plot x-axis. Can be specified as a number from 1 to 365, as a character string of form "yyyy-mm-dd", or as a date object. Either way the day of year is the only portion used, specify years to plot under parameter `years`.
#' @param endDay The end day of year for the plot x-axis. As per `startDay`.
#' @param tzone The timezone to use for graphing. Only really evident for a small number of days.
#' @param years The years to plot. If `startDay` and `endDay` cover December 31 - January 1, select the December year(s). Max 10 years, NULL = current year. Currently, only 1 year can be provided for when other data is provided to function.
#' @param datum Should a vertical datum be applied to the data, if available? TRUE or FALSE.
#' @param title Should a title be included?
#' @param custom_title Custom title to be given to the plot. Default is NULL, which will set the title as Location <<location id>>: <<location name>>. Ex: Location 09AB004: Marsh Lake Near Whitehorse.
#' @param filter Should an attempt be made to filter out spurious data? Will calculate the rolling IQR and filter out clearly spurious values. Set this parameter to an integer, which specifies the rolling IQR 'window'. The greater the window, the more effective the filter but at the risk of filtering out real data. Negative values are always filtered from parameters "level" ("niveau d'eau"), "flow" ("d√©bit d'eau"), "snow depth" ("profondeur de la neige"), "SWE" ("EEN"), "distance", and any "precip" related parameter. Otherwise all values below -100 are removed.
#' @param historic_range Should the historic range parameters be calculated using all available data (i.e. from start to end of records) or only up to the last year specified in "years"? Choose one of "all" or "last".
#' @param returns Should returns be plotted? You have the option of using pre-determined level returns only (option "table"), auto-calculated values(option "calculate"), "auto" (priority to "table", fallback to "calculate"), or "none". Defaults to "auto".
#' @param return_type Use minimum ("min") or maximum ("max") values for returns?
#' @param return_months Numeric vector of months during which to look for minimum or maximum values. Only works with calculated returns. Does not have to be within `startDay` and `endDay`, but will only consider data up to the last year specified in `years`. For months overlapping the new year like November-April, should look like c(11:12,1:4). IMPORTANT: the first month in the range should be the first element of the vector: c(1:4, 11:12) would not be acceptable. Think of it as defining a season. Passed to 'months' argument of [fasstr::calc_annual_extremes()] and also used to set the 'water_year_start' parameter of this function.
#' @param return_max_year The last year of data to consider when calculating returns. If left NULL behavior depends on parameter `historic_range`: if `historic_range` is set to 'last' defaults to the last year in `year` otherwise uses all data available. Automatically set to max(years) if `historic_range` is 'last', otherwise set to the current year.
#' @param allowed_missing Allowable % of data missing during the months specified in 'return_months' to still retain the year for analysis when calculating returns. Passed to 'allowed_missing' argument of [fasstr::calc_annual_extremes()].
#' @param plot_scale Adjusts/scales the size of plot text elements. 1 = standard size, 0.5 = half size, 2 = double the size, etc. Standard size works well in a typical RStudio environment.
#' @param legend Should a legend (including text for min/max range and return periods) be added to the plot?
#' @param save_path Default is NULL and the graph will be visible in RStudio and can be assigned to an object. Option "choose" brings up the File Explorer for you to choose where to save the file, or you can also specify a save path directly.
#' @param con A connection to the database. Default uses function [hydrometConnect()].
#' @param continuous_data A data.frame with the data to be plotted. Must contain the following columns: datetime, value.
#' @param snowbulletin If TRUE, data will be plotted to the snow bulletin standards. Lines will be smoothed and max/min lines are added.
#' @return A .png file of the plot requested (if a save path has been selected), plus the plot displayed in RStudio. Assign the function to a variable to also get a plot in your global environment as a ggplot object which can be further modified.
#' @param language The language to use for the plot. Currently only "en" and "fr" are supported. Default is "en".
#' @export
#'

plotOverlap <- function(location = NULL,
                        parameter = NULL,
                        record_rate = NULL,
                        startDay = 1,
                        endDay = 365,
                        tzone = "MST",
                        years = NULL,
                        datum = TRUE,
                        title = TRUE,
                        custom_title = NULL,
                        filter = NULL,
                        historic_range = "all",
                        returns = "auto",
                        return_type = "max",
                        return_months = c(5:9),
                        return_max_year = NULL,
                        allowed_missing = 10,
                        plot_scale = 1,
                        legend = TRUE,
                        save_path = NULL,
                        con = hydrometConnect(silent = TRUE),
                        continuous_data = NULL,
                        snowbulletin = FALSE,
                        language = "en")
{
  
  #Suppress warnings otherwise ggplot annoyingly flags every geom that wasn't plotted
  options(warn = -1)
  old_warn <- getOption("warn")
  on.exit(options(warn = old_warn), add = TRUE)

  #### --------- Checks on input parameters and other start-up bits ------- ####
  if (!(parameter %in% c("EEN", "SWE"))) {
    parameter <- tolower(parameter)
  }
  
  if (!(language %in% c("en", "fr"))) {
    stop("Your entry for the parameter 'language' is invalid. Please review the function documentation and try again.")
  }

  if (language == "fr") {
    lc <- Sys.getlocale("LC_ALL")
    Sys.setlocale("LC_ALL", "French")
    on.exit(Sys.setlocale("LC_ALL", lc), add = TRUE)
  } else if (language == "en") {
    lc <- Sys.getlocale("LC_ALL")
    Sys.setlocale("LC_ALL", "English")
    on.exit(Sys.setlocale("LC_ALL", lc), add = TRUE)
  }

  if (!is.null(record_rate)) {
    if (!(record_rate %in% c('< 1 day', '1 day', '1 week', '4 weeks', '1 month', 'year'))) {
      warning("Your entry for parameter record_rate is invalid. It's been reset to the default NULL.")
      record_rate <- NULL
    }
  }

  return_type <- tolower(return_type)
  returns <- tolower(returns)
  if (!returns %in% c("table", "auto", "calculate", "none")) {
    stop("Your entry for the parameter 'return' is invalid. Please review the function documentation and try again.")
  }

  if (is.null(years)) {
    years <- lubridate::year(Sys.Date())
  } else {
    years <- as.numeric(years)
    years <- sort(years)
    if (length(years) > 10) {
      years <- years[(length(years) - 10):length(years)]
      message("The parameter 'years' can only have up to 10 years. It's been truncated to the most recent 10 years.")
    }
  }
  
  # Select save path
  if (!is.null(save_path)) {
    if (save_path %in% c("Choose", "choose")) {
      # print("Select the folder where you want this graph saved.")
      save_path <- rstudioapi::selectDirectory(caption = "Select Save Folder", path = file.path(Sys.getenv("USERPROFILE"), "Desktop"))
    } else {
      if (!dir.exists(save_path)) {
        stop("The directory you pointed to with parameter 'save_path' does not exist")
      }
    }
  }

  if (!(historic_range %in% c("all", "last"))) {
    warning("Parameter `historic_range` can only be 'all' or 'last'. Resetting it to the default 'all'.")
    historic_range <- "all"
  }

  if (is.null(return_max_year)) {
    if (historic_range == "last") {
      return_max_year <- max(years)
    } else {
      return_max_year <- lubridate::year(Sys.Date())
    }
  } else {
    if (return_max_year > max(years) & historic_range == "last") {
      return_max_year <- max(years)
      message("Your parameter entry for 'return_max_year' is invalid (greater than the last year to plot). It has been adjusted to the last year to plot. See the help file for other options.")
    }
  }


  #### ------------------ Dealing with start/end dates ---------------------- ####
  # Sort out startDay and endDay into actual dates if needed
  last_year <- max(years)

  leap_list <- (seq(1800, 2100, by = 4))  # Create list of all leap years
  tryCatch({ #This part will fail if startDay specified as a number
    startDay <- as.character(startDay)
    startDay <- as.POSIXct(startDay, tz = tzone)
    lubridate::year(startDay) <- last_year
  }, error = function(e) {
    startDay <<- as.numeric(startDay)
    if (last_year %in% leap_list & length(years) > 1) { #Skips over Feb 29 because feb 29 has no historical info
      if (startDay == 59) {
        startDay <<- startDay + 1
      }
    }
    startDay <<- as.POSIXct(startDay*60*60*24, origin = paste0(last_year - 1, "-12-31"), tz = "UTC")
    startDay <<- lubridate::force_tz(startDay, tzone)
  })
  tryCatch({ #This part will fail if endDay specified as a number
    endDay <- as.character(endDay)
    endDay <- as.POSIXct(endDay, tz = tzone)
    lubridate::year(endDay) <- last_year
  }, error = function(e) {
    endDay <<- as.numeric(endDay)
    if (last_year %in% leap_list & length(years) > 1) { #Skips over Feb 29 because feb 29 has no historical info
      if (endDay == 59) {
        if (endDay < 366) {
          endDay <<- endDay + 1
        }
      }
    }
    endDay <<- as.POSIXct(endDay*60*60*24, origin = paste0(last_year - 1, "-12-31 23:59:59"), tz = "UTC")
    endDay <<- lubridate::force_tz(endDay, tzone)
  })
  if (startDay > endDay) { #if the user is wanting a range overlapping the new year
    lubridate::year(endDay) <- lubridate::year(endDay) + 1
    overlaps <- TRUE
  } else {
    overlaps <- FALSE
  }

  if (startDay > Sys.Date()) { #If left like this it results in wonky ribbon plotting and extra 'ghost' timeseries. Since there would be no data anyways change the year, endDay can stay in the future to enable plotting graphs with only the ribbon beyond the last day.
    diff <- as.numeric(endDay - startDay)
    lubridate::year(startDay) <- lubridate::year(Sys.Date())
    if (startDay > Sys.Date()) { #Depending on where we are in the year and what the startDay is, startDay could still be in the future.
      lubridate::year(startDay) <- lubridate::year(Sys.Date()) - 1
    }
    endDay <- startDay + (diff*60*60*24)
  }

  day_seq <- seq.POSIXt(startDay, endDay, by = "day")
  if (length(day_seq) < 30) {
    warning("The date range you have selected is less than 30 days. This graph type is not optimized for fewer than 30 days.")
  }

  #### ------------------------- Data is not provided ---------------------- ####
  if (is.null(continuous_data)) {
    location_id <- DBI::dbGetQuery(con, paste0("SELECT location_id FROM locations WHERE location = '", location, "';"))[1,1]
    #Confirm parameter and location exist in the database and that there is only one entry
    escaped_parameter <- gsub("'", "''", parameter)
    parameter_tbl <- DBI::dbGetQuery(con, paste0("SELECT param_code, param_name, param_name_fr FROM parameters WHERE param_name = '", escaped_parameter, "' OR param_name_fr = '", escaped_parameter, "';"))
    parameter_code <- parameter_tbl$param_code[1]
    if (language == "fr") {
      parameter_name <- titleCase(parameter_tbl$param_name_fr[1], "fr")
    } else if (language == "en" || is.na(parameter_name)) {
      parameter_name <- titleCase(parameter_tbl$param_name[1], "en")
    }
    if (is.na(parameter_code)) {
      stop("The parameter you entered does not exist in the database.")
    }
    if (is.null(record_rate)) {
      exist_check <- DBI::dbGetQuery(con, paste0("SELECT timeseries_id, record_rate FROM timeseries WHERE location_id = ", location_id, " AND parameter = ", parameter_code, " AND category = 'continuous' AND period_type = 'instantaneous';"))
    } else {
      exist_check <- DBI::dbGetQuery(con, paste0("SELECT timeseries_id FROM timeseries WHERE location_id = ", location_id, " AND parameter = ", parameter_code, " AND category = 'continuous' AND period_type = 'instantaneous' AND record_rate = '", record_rate, "';"))
    }
    if (nrow(exist_check) == 0) {
      if (is.null(record_rate)) {
        stop("There doesn't appear to be a match in the database for location ", location, ", parameter ", parameter, ", and continuous category data.")
      } else {
        stop("There doesn't appear to be a match in the database for location ", location, ", parameter ", parameter, ", record rate ", record_rate, " and continuous category data. You could try leaving the record rate to the default 'null'.")
      }
    } else if (nrow(exist_check) > 1) {
      if (is.null(record_rate)) {
        warning("There is more than one entry in the database for location ", location, ", parameter ", parameter, ", and continuous category data. Since you left the record_rate as NULL, selecting the one with the most frequent recording rate.")
        tsid <- exist_check[exist_check$record_rate == "< 1 day", "timeseries_id"]
        if (is.na(tsid)) {
          tsid <- exist_check[exist_check$record_rate == "1 day", "timeseries_id"]
        }
        if (is.na(tsid)) {
          tsid <- exist_check[exist_check$record_rate == "1 week", "timeseries_id"]
        }
        if (is.na(tsid)) {
          tsid <- exist_check[exist_check$record_rate == "4 weeks", "timeseries_id"]
        }
        if (is.na(tsid)) {
          tsid <- exist_check[exist_check$record_rate == "1 month", "timeseries_id"]
        }
        if (is.na(tsid)) {
          tsid <- exist_check[exist_check$record_rate == "year", "timeseries_id"]
        }
      }
    } else if (nrow(exist_check) == 1) {
      tsid <- exist_check$timeseries_id
    }

    # Find the necessary datum (latest datum)
    if (datum & parameter %in% c("water level", "distance")) {
      datum <- DBI::dbGetQuery(con, paste0("SELECT conversion_m FROM datum_conversions WHERE location_id = ", location_id, " AND current = TRUE"))
    } else {
      datum <- data.frame(conversion_m = 0)
    }

    # Find the ts units
    units <- DBI::dbGetQuery(con, paste0("SELECT unit FROM timeseries WHERE timeseries_id = ", tsid, ";"))

    # Get the necessary data -------------------
    # start with daily means data
    daily_end <- endDay
    if (historic_range == "all") {
      lubridate::year(daily_end) <- lubridate::year(Sys.time())
      daily_end <- daily_end + 60*60*24 #adds a day so that the ribbon is complete for the whole plotted line
      if (lubridate::month(daily_end) == 2 & lubridate::day(daily_end) == 29) {
        daily_end <- daily_end + 60*60*24
      }
      daily <- DBI::dbGetQuery(con, paste0("SELECT date, value, max, min, q75, q25 FROM calculated_daily WHERE timeseries_id = ", tsid, " AND date <= '", daily_end, "';"))
    } else if (historic_range == "last") {
      if (overlaps) {
        lubridate::year(daily_end) <- last_year + 1
      } else {
        lubridate::year(daily_end) <- last_year
      }
      daily_end <- daily_end + 60*60*24 #adds a day so that the ribbon is complete for the whole plotted line
      if (lubridate::month(daily_end) == 2 & lubridate::day(daily_end) == 29) {
        daily_end <- daily_end + 60*60*24
      }
      daily <- DBI::dbGetQuery(con, paste0("SELECT date, value, max, min, q75, q25 FROM calculated_daily WHERE timeseries_id = ", tsid, " AND date <= '", daily_end, "';"))
    }

    #Fill in any missing days in daily
    all_dates <- seq(min(daily$date), max(daily$date), by = "1 day")
    complete <- data.frame(date = all_dates, value = NA, max = NA, min = NA, q75 = NA, q25 = NA)
    complete[match(daily$date, all_dates) , ] <- daily
    daily <- complete

    daily$date <- as.POSIXct(daily$date) #to posixct and not date so that it plays well with realtime df
    daily$date <- lubridate::force_tz(daily$date, tzone)
    names(daily)[names(daily) == "date"] <- "datetime"

    dates <- lubridate::POSIXct(tz = tzone) #creates empty posixct vector to hold days missing realtime data and needing to be infilled with daily
    realtime <- data.frame()
    for (i in rev(years)) { #Using rev so that the most recent year gets realtime, if possible
      start <- as.POSIXct(paste0(i, substr(startDay, 5, 16)), tz = tzone)
      start_UTC <- start
      attr(start_UTC, "tzone") <- "UTC"
      end <- as.POSIXct(paste0(i, substr(endDay, 5, 10), " 23:59:59"), tz = tzone)
      if (overlaps) {
        lubridate::year(end) <- lubridate::year(end) + 1
      }
      end_UTC <- end
      attr(end_UTC, "tzone") <- "UTC"
      if (length(day_seq) < 90) { # 90 days at 5 minute data points is 25920 rows.
        if (nrow(realtime) < 20000) { # if plotting 70-90 days of 5 minute data will only have the greatest year with 5 minute points
          new_realtime <- DBI::dbGetQuery(con, paste0("SELECT datetime, value FROM measurements_continuous WHERE timeseries_id = ", tsid, " AND datetime BETWEEN '", as.character(start_UTC), "' AND '", as.character(end_UTC), "' AND value IS NOT NULL")) #SQL BETWEEN is inclusive. null values are later filled with NAs for plotting purposes.
          if (nrow(new_realtime) > 20000) {
            new_realtime <- new_realtime[order(new_realtime$datetime) , ]
            new_realtime <- utils::tail(new_realtime, 20000) #Retain only max 20000 data points for plotting performance
            end_new_dates <- min(new_realtime$datetime)
            new_dates <- seq.POSIXt(start, end_new_dates, by = "days")
            dates <- c(dates, new_dates)
          }
          if (nrow(new_realtime) > 0) {
            realtime <- rbind(realtime, new_realtime)
            get_daily <- FALSE
          } else {
            get_daily <- TRUE
          }
        } else {
          get_daily <- TRUE
        }
      } else {
        get_daily <- TRUE
      }
      if (get_daily) {
        new_realtime <- daily[daily$datetime >= start & daily$datetime <= end , c("datetime", "value")]
        if (nrow(new_realtime) > 0) {
          realtime <- rbind(realtime, new_realtime)
        }
      }
    }
    # Find out where values need to be filled in with daily means
    if (length(dates) > 0) {
      for (i in 1:length(dates)) {
        toDate <- as.Date(dates[i]) #convert to plain date to check if there are any datetimes with that plain date in the data.frame
        if (!(toDate %in% as.Date(realtime$datetime))) {
          row <- daily[daily$datetime == dates[i] , c("datetime", "value")]
          realtime <- rbind(realtime, row)
        }
      }
    }
    if (nrow(realtime) == 0) {
      stop("There is no data to plot within this range of years and days. If you're wanting a plot overlaping the new year, remember that the last year requested should be the *December* year.")
    }

    # Add the ribbon values ######################
    # Make the ribbon sequence
    ribbon_yr <- lubridate::year(min((max(daily$datetime) - 24*60*60), (daily_end - 24*60*60))) #Daily was queried as one day longer than the day sequence earlier... this reverses that one day extra, but also finds out if the actual data extracted doesn't go that far back
    if (overlaps) {
      if (historic_range == "all") {
        ribbon_seq <- seq.POSIXt(as.POSIXct(paste0(ribbon_yr - 1, substr(startDay, 5, 16)), tz = tzone), as.POSIXct(paste0(ribbon_yr, substr(endDay, 5, 16)), tz = tzone), by = "day")
      } else {
        ribbon_seq <- seq.POSIXt(as.POSIXct(paste0(last_year, substr(startDay, 5, 16)), tz = tzone), as.POSIXct(paste0(last_year + 1, substr(endDay, 5, 16)), tz = tzone), by = "day")
      }
    } else {
      if (historic_range == "all") {
        ribbon_seq <- seq.POSIXt(as.POSIXct(paste0(ribbon_yr, substr(startDay, 5, 16)), tz = tzone), as.POSIXct(paste0(ribbon_yr, substr(endDay, 5, 16)), tz = tzone), by = "day")
      } else {
        ribbon_seq <- seq.POSIXt(as.POSIXct(paste0(last_year, substr(startDay, 5, 16)), tz = tzone), as.POSIXct(paste0(last_year, substr(endDay, 5, 16)), tz = tzone), by = "day")
      }
    }

    ribbon <- data.frame()
    ribbon_start_end <- if (overlaps) paste0(lubridate::year(min(daily$datetime)), "-", lubridate::year(min(daily$datetime)) + 1 ) else lubridate::year(min(daily$datetime))
    for (i in 1:length(ribbon_seq)) {
      target_date <- ribbon_seq[i]
      plot_date <- day_seq[i]
      if (is.na(plot_date)) {
        plot_date <- day_seq[i - 1] + 60*60*24 - 1
      }
      if (!(lubridate::month(target_date) == 2 & lubridate::day(target_date) == 29)) { #Can't have the Feb 29 date because there is no Feb 29 ribbon
        row <- daily[daily$datetime == target_date, !names(daily) %in% c("value", "grade", "approval")]
        if (nrow(row) == 0) {
          lubridate::year(target_date) <- lubridate::year(target_date) - 1
          if (is.na(target_date)) {
            next()
          }
          row <- daily[daily$datetime == target_date, !names(daily) %in% c("value", "grade", "approval")]
        }
        lubridate::year(row$datetime) <- lubridate::year(plot_date)
        if (i == length(ribbon_seq)) {
          row$datetime <- row$datetime - 1 #This keeps the last ribbon point within the same days as the day sequence requested. Without this, a last day requested of 365 causes a point to show up in the following year.
          ribbon_start_end <- if (overlaps) c(ribbon_start_end, paste0(lubridate::year(target_date) - 2, "-", lubridate::year(target_date) - 1)) else c(ribbon_start_end, lubridate::year(target_date) - 1)
        }
        if (nrow(row) > 0) {
          ribbon <- rbind(ribbon, row)
        }
      }
    }
    if (nrow(ribbon) > 0) {
      if (min(ribbon$datetime) < min(realtime$datetime)) {
        first_date <- min(realtime$datetime)
        lubridate::hour(first_date) <- 0
        ribbon[ribbon$datetime == min(ribbon$datetime), "datetime"] <- first_date
      }
      realtime <- merge(realtime, ribbon, all = TRUE, by = "datetime")
    } else {
      realtime$max <- NA
      realtime$min <- NA
      realtime$q75 <- NA
      realtime$q25 <- NA
    }


    realtime$year <- lubridate::year(realtime$datetime) #year, month columns used for removing Feb 29 later
    realtime$month <- lubridate::month(realtime$datetime)
    realtime$day <- lubridate::day(realtime$datetime)
    realtime <- realtime[!(realtime$month == 2 & realtime$day == 29), ] #Remove Feb 29
    daily$year <- lubridate::year(daily$datetime)
    daily$month <- lubridate::month(daily$datetime)
    daily$day <- lubridate::month(daily$datetime)
    daily <- daily[!(daily$month == 2 & daily$day == 29), ] #Remove Feb 29

    if (overlaps) { # This section sorts out the overlap years, builds the plotting column
      temp <- data.frame(date = day_seq)
      temp$year = lubridate::year(temp$date)
      temp <- temp[!(temp$year == max(temp$year)), ] #Remove the rows for days after the new year
      temp$month = lubridate::month(temp$date)
      temp$day = lubridate::day(temp$date)
      temp$day <- stringr::str_pad(temp$day, 2, side = "left", pad = "0")

      #Column md is built in both temp and realtime dfs to be able to differentiate the previous year from the next and assign proper plot years (i.e. 2022-2023) and fake datetimes (since every year needs the same "fake year" to plot together)
      temp$md <- paste0(temp$month, temp$day)
      temp$md <- as.numeric(temp$md)
      md_sequence <- seq(min(temp$md), max(temp$md))

      realtime$day <- stringr::str_pad(realtime$day, 2, side = "left", pad = "0")
      realtime$md <- paste0(realtime$month, realtime$day)
      realtime$md <- as.numeric(realtime$md)

      realtime$fake_datetime <- as.POSIXct(rep(NA, nrow(realtime)))
      realtime$plot_year <- NA
      for (i in 1:nrow(realtime)) {  #!!!This desperately needs to be vectorized in some way. Super slow!
        fake_datetime <- gsub("[0-9]{4}", if (realtime$md[i] %in% md_sequence) last_year else last_year + 1, realtime$datetime[i])
        fake_datetime <- ifelse(nchar(fake_datetime) > 11, fake_datetime, paste0(fake_datetime, " 00:00:00"))
        realtime$fake_datetime[i] <- as.POSIXct(fake_datetime, tz = tzone)
        realtime$plot_year[i] <- if (realtime$md[i] %in% md_sequence) paste0(realtime$year[i], "-", realtime$year[i] + 1) else paste0(realtime$year[i] - 1, "-", realtime$year[i])
      }
    } else { #Does not overlap the new year
      realtime$plot_year <- as.character(realtime$year)
      realtime$fake_datetime <- gsub("[0-9]{4}", last_year, realtime$datetime)
      realtime$fake_datetime <- ifelse(nchar(realtime$fake_datetime) > 11, realtime$fake_datetime, paste0(realtime$fake_datetime, " 00:00:00"))
      realtime$fake_datetime <- as.POSIXct(realtime$fake_datetime, tz = tzone, format = '%Y-%m-%d %H:%M:%S') #Make fake datetimes to permit plotting years together as separate lines. This DOESN'T work if Feb 29 isn't removed first!
    }

    # apply datum correction where necessary
    if (datum$conversion_m > 0) {
      daily[ , c("value", "max", "min", "q75", "q25")] <- apply(daily[ , c("value", "max", "min", "q75", "q25")], 2, function(x) x + datum$conversion_m)
      realtime[ , c("value", "max", "min", "q75", "q25")] <- apply(realtime[ , c("value", "max", "min", "q75", "q25")], 2, function(x) x + datum$conversion_m)
    }
  }


  #### --------------------------- Data provided -------------------------- ####

  if (!is.null(continuous_data)) {
    if (!all(names(continuous_data) %in% c("datetime", "value"))) {
      stop("The data.frame passed to parameter 'continuous_data' must have columns named 'datetime' and 'value'.")
    }
    parameter_name <- if (!(parameter %in% c("SWE", "EEN"))) titleCase(parameter) else parameter
    #### Add this in here: ------------------
    dat <- continuous_data
    # Remove Feb 29
    dat$monthday <- format(dat$datetime, "%m-%d")
    dat <- dat[dat$monthday != "02-29",]
    dat <- dat[, c("datetime", "value")]
    # Calculate min, max, median
    dat$day <- format(dat$datetime, "%m-%d")
    summary_dat <- dat %>%
      dplyr::group_by(.data$day) %>%
      dplyr::summarise(min = round(min(value), 0),
                       max = round(max(value), 0),
                       md = round(stats::median(value), 0),
                       q75 = round(stats::quantile(value, 0.75), 0),
                       q25 = round(stats::quantile(value, 0.25), 0))

    # Add date
    summary_dat$datetime <- NA

    # Use startay and endDay to set up for plotting and merge dat with summary_dat
    if (overlaps) {
      summary_dat[summary_dat$day >= format(startDay, "%m-%d") & summary_dat$day <= "12-31",]$datetime <- paste0(years, "-", summary_dat[summary_dat$day >= format(startDay, "%m-%d") & summary_dat$day <= "12-31",]$day )
      summary_dat[summary_dat$day >= "01-01" & summary_dat$day <= format(endDay, "%m-%d"),]$datetime <- paste0(years + 1, "-", summary_dat[summary_dat$day >= "01-01" & summary_dat$day <= format(endDay, "%m-%d"),]$day )
      summary_dat$datetime <- as.POSIXct(summary_dat$datetime, format = "%Y-%m-%d")
      dat$datetime <- as.POSIXct(dat$datetime, format = "%Y-%m-%d")

      # Add columns for year and value. If want to add additional years, then would only need to add value, not stats
      if (parameter == "cddf") {
        tab <- merge(summary_dat, dat[dat$datetime >= paste0(years, '-09-01')
                                      & dat$datetime <= paste0(years + 1, '-06-14'),], by = c("day"), all.x = TRUE)
      } else {
        tab <- merge(summary_dat, dat[dat$datetime >= paste0(years, "-", format(startDay, "%m-%d"))
                                      & dat$datetime <= paste0(years + 1, "-", format(endDay, "%m-%d")),], by = c("day"), all.x = TRUE)
      }
    } else {
      summary_dat[summary_dat$day >= format(startDay, "%m-%d") & summary_dat$day <= format(endDay, "%m-%d"),]$datetime <- paste0(years, "-", summary_dat[summary_dat$day >= format(startDay, "%m-%d") & summary_dat$day <= format(endDay, "%m-%d"),]$day )

      summary_dat$datetime <- as.POSIXct(summary_dat$datetime, format = "%Y-%m-%d")

      dat$datetime <- as.POSIXct(dat$datetime, format = "%Y-%m-%d")

      tab <- merge(summary_dat, dat[dat$datetime >= paste0(years, "-", format(startDay, "%m-%d"))
                                    & dat$datetime <= paste0(years, "-", format(endDay, "%m-%d")),], by = c("day"), all.x = TRUE)
    }
    if (overlaps) {
      ribbon_start_end <- c(paste0(lubridate::year(min(summary_dat$datetime)), "-", lubridate::year(min(summary_dat$datetime)) + 1), paste0(lubridate::year(max(summary_dat$datetime)) - 1, "-", lubridate::year(max(summary_dat$datetime))))
    } else {
      ribbon_start_end <- c(lubridate::year(min(summary_dat$datetime)), lubridate::year(max(summary_dat$datetime)))
    }


    # rename columns
    colnames(tab) <- c("day", "min", "max", "md", "q75", "q25", "datetime", "datetime.y", "value")
    # Add columns to imitate hydrometContinuous realtime table
    tab$year <- format(tab$datetime, "%Y")
    tab$month <- format(tab$datetime, "%m")
    tab$day <- format(tab$datetime, "%d")
    tab$plot_year <- paste0(years, "-", years + 1)
    tab$datetime <- as.POSIXct(tab$datetime, format = "%Y-%m-%d")
    tab$fake_datetime <- tab$datetime

    #####----------------
    realtime <- tab
    daily <- continuous_data
    day_seq <- realtime$datetime
    units <- "\u00B0C"

  } #End of loop integrating provided data

  if (snowbulletin == TRUE) {
    # Order realtime by fake_datetime
    realtime <- realtime[order(realtime$fake_datetime),]
    # Apply rolling mean
    realtime$q25 <- zoo::rollmean(realtime$q25, 5, fill = NA, align = "left")
    realtime$q75 <- zoo::rollmean(realtime$q75, 5, fill = NA, align = "left")
    realtime$min <- zoo::rollmean(realtime$min, 5, fill = NA, align = "left")
    realtime$max <- zoo::rollmean(realtime$max, 5, fill = NA, align = "left")
  }

  if (!is.null(filter)) {
    if (!inherits(filter, "numeric")) {
      message("Parameter 'filter' was modified from the default NULL but not properly specified as a class 'numeric'. Filtering will not be done.")
    } else {
      if (parameter %in% c("water level", "niveau d'eau", "water flow", "d\u00E9bit d'eau", "snow depth", "profondeur de la neige", "SWE", "EEN", "distance") | grepl("precip", parameter, ignore.case = TRUE)) { #remove all values less than 0
        realtime[realtime$value < 0 & !is.na(realtime$value),"value"] <- NA
      } else { #remove all values less than -100 (in case of negative temperatures or -DL values in lab results)
        realtime[realtime$value < -100 & !is.na(realtime$value),"value"] <- NA
      }

      rollmedian <- zoo::rollapply(realtime$value, width = filter, FUN = "median", align = "center", fill = "extend", na.rm = TRUE)
      rollmad <- zoo::rollapply(realtime$value, width = filter, FUN = "mad", align = "center", fill = "extend", na.rm = TRUE)
      outlier <- abs(realtime$value - rollmedian) > 5 * rollmad
      realtime$value[outlier] <- NA
    }
  }

  #### ----------------------------- Make the plot -------------------------- ####
  line_size = 1
  minHist <- min(realtime$min, na.rm = TRUE)
  maxHist <- max(realtime$max, na.rm = TRUE)
  minLines <- min(realtime$value, na.rm = TRUE)
  maxLines <- max(realtime$value, na.rm = TRUE)
  min <- if (minHist < minLines) minHist else minLines
  max <- if (maxHist > maxLines) maxHist else maxLines

  # x axis settings
  if  (length(day_seq) > 200) {
    date_breaks = "2 months"
    if (language == "fr") {
      labs = "%d %b"
    } else {
      labs = "%b %d"
    }
  } else if (length(day_seq) > 60) {
    date_breaks = "1 month"
    if (language == "fr") {
      labs = "%d %b"
    } else {
      labs = "%b %d"
    }
  } else if (length(day_seq) > 14) {
    date_breaks = "1 week"
    if (language == "fr") {
      labs = "%d %b"
    } else {
      labs = "%b %d"
    }
  } else if (length(day_seq) > 7) {
    date_breaks = "2 days"
    if (language == "fr") {
      labs = "%d %b"
    } else {
      labs = "%b %d"
    }
  } else if (length(day_seq) >= 2) {
    date_breaks = "1 days"
    if (language == "fr") {
      labs = "%d %b"
    } else {
      labs = "%b %d"
    }
  } else if (length(day_seq) > 1) {
    date_breaks = "24 hours"
    if (language == "fr") {
      labs = "%H:%M"
    } else {
      labs = "%H:%M"
    }
  } else if (length(day_seq) == 1) {
    date_breaks = "12 hour"
    if (language == "fr") {
      labs = "%H:%M"
    } else {
      labs = "%H:%M"
    }
  }

  plot <- ggplot2::ggplot(realtime, ggplot2::aes(x = .data$fake_datetime, y = .data$value)) +
      ggplot2::scale_y_continuous(limits = c(min, max), expand = c(0,0.05)) + # The expand argument controls space between the data and the y axis. Default for continuous variable is 0.05
    ggplot2::scale_x_datetime(date_breaks = date_breaks, date_labels = labs, expand = c(0,0)) + # The expand argument controls space between the data and the y axis. Default for continuous variable is 0.05
    ggplot2::labs(x = NULL, y =  paste0(parameter_name, " (", units, ")")) +
    ggplot2::theme_classic()
  if (legend) {
    plot <- plot + ggplot2::theme(legend.position = "right", legend.justification = c(0, 0.95), legend.text = ggplot2::element_text(size = 8*plot_scale), legend.title = ggplot2::element_text(size = 9*plot_scale), axis.title.y = ggplot2::element_text(size = 12*plot_scale), axis.text.x = ggplot2::element_text(size = 11*plot_scale), axis.text.y = ggplot2::element_text(size = 11*plot_scale))
  } else {
    plot <- plot + ggplot2::theme(legend.position = "none", axis.title.y = ggplot2::element_text(size = 12*plot_scale), axis.text.x = ggplot2::element_text(size = 11*plot_scale), axis.text.y = ggplot2::element_text(size = 11*plot_scale))
  }

  if (!is.infinite(minHist)) {
    if (!identical(realtime$min, realtime$max)) { #if they're identical there's nothing to plot!
      plot <- plot +
        ggplot2::geom_ribbon(ggplot2::aes(ymin = .data$min, ymax = .data$max, fill = "Min - Max"), na.rm = T)
      if (!all(is.na(realtime$q25))) {
        plot <- plot +
          ggplot2::geom_ribbon(ggplot2::aes(ymin = .data$q25, ymax = .data$q75, fill = if (language == "en") "25th-75th Percentile  " else "25e-75e percentile    "), na.rm = T) +
          ggplot2::scale_fill_manual(name = if (language == "en") "Historical Range" else "Plage historique", values = if (language == "en") c("Min - Max" = "gray90", "25th-75th Percentile  " = "gray80") else c("Min - Max" = "gray90", "25e-75e percentile    " = "gray80"))
      } else {
        plot <- plot +
          ggplot2::scale_fill_manual(name = if (language == "en") "Historical Range" else "Plage historique", values = c("Min - Max" = "gray90"))
      }
    } else {
      minHist <- Inf # set to Inf here so that historical range is not printed later on the graph
    }
  }

  if (snowbulletin == FALSE) {
    plot <- plot +
      ggplot2::geom_line(ggplot2::aes(colour = .data$plot_year, group = .data$plot_year), linewidth = line_size, na.rm = T) +
      ggplot2::scale_colour_manual(name = if (language == "en") "Year" else "Ann\u00E9e", labels = rev(unique(realtime$plot_year)), values = grDevices::colorRampPalette(c("#0097A9", "#7A9A01", "#F2A900","#DC4405"))(length(unique(realtime$plot_year))), na.translate = FALSE, breaks = rev(unique(realtime$plot_year)))
  } else {
    plot <- plot +
      ggplot2::geom_line(ggplot2::aes(y = max), colour = "#0097A9", size = 1) +
      ggplot2::geom_line(ggplot2::aes(y = min), colour = "#834333", size = 1) +
      ggplot2::geom_line(colour = "black", linewidth = line_size, na.rm = T)
  }
  
  # Get or calculate return periods -------------
  label_en <- c("two year return", "five year return", "ten year return", "twenty year return", "fifty year return", "one hundred year return", "two hundred year return", "five hundred year return", "one-thousand year return", "two-thousand year return")
  label_fr <- c("retour de deux ans", "retour de cinq ans", "retour de dix ans", "retour de vingt ans", "retour de cinquante ans", "retour de cent ans", "retour de deux cents ans", "retour de cinq cents ans", "retour de mille ans", "retour de deux mille ans")
  if (returns != "none") {
    if (returns %in% c("table", "auto")) {
      #search for the location in the table
      returns_table <- paste0(parameter, "_returns_", return_type)
      if (location %in% data[[returns_table]]$ID) {
        returns <- "table"
        loc_returns <- data[[returns_table]][data[[returns_table]]$ID == location , ]
        loc_returns[ , c("twoyear", "fiveyear", "tenyear", "twentyyear", "fiftyyear", "onehundredyear", "twohundredyear", "fivehundredyear", "thousandyear", "twothousandyear", "LSL", "FSL")] <- apply(loc_returns[ , c("twoyear", "fiveyear", "tenyear", "twentyyear", "fiftyyear", "onehundredyear", "twohundredyear", "fivehundredyear", "thousandyear", "twothousandyear", "LSL", "FSL")], 2, function(x) x + datum$conversion_m)
        loc_returns[is.na(loc_returns) == TRUE] <- -10 #This prevents a ggplot error when it tries to plot a logical along with numerics, but keeps the values out of the plot.

        plot <- plot +
          ggplot2::geom_hline(yintercept = loc_returns$twoyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$fiveyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$tenyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$twentyyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$fiftyyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$onehundredyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$twohundredyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$fivehundredyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$thousandyear, linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = loc_returns$twothousandyear, linetype = "dashed", color = "black") +
          ggplot2::annotate("text", x = mean(realtime$fake_datetime), y = c(loc_returns$twoyear, loc_returns$fiveyear, loc_returns$tenyear, loc_returns$twentyyear, loc_returns$fiftyyear, loc_returns$onehundredyear, loc_returns$twohundredyear, loc_returns$fivehundredyear, loc_returns$thousandyear, loc_returns$twothousandyear), label = if (language == "en") label_en else if (language == "fr") label_fr, size = 2.6*plot_scale, vjust = -.2*plot_scale)
      } else if (returns == "auto") { # if there is no entry to the table AND the user specified auto, calculate loop will run after this
        returns <- "calculate"
      }
    }
    if (returns == "calculate") {
      tryCatch({
        extremes <- suppressWarnings(fasstr::calc_annual_extremes(daily[daily$year <= return_max_year , ], dates = datetime, values = value, water_year_start = return_months[1], months = return_months, allowed_missing = allowed_missing))
        extremes$Measure <- "1-Day"
        if (return_type == "max") {
          analysis <- fasstr::compute_frequency_analysis(data = extremes, events = "Year", values = "Max_1_Day", use_max = TRUE, fit_quantiles = c(0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005))
          return_yrs <- c(min(lubridate::year(analysis$Freq_Analysis_Data$Max_1_Day_Date)), max(lubridate::year(analysis$Freq_Analysis_Data$Max_1_Day_Date)))
        } else if (return_type == "min") {
          analysis <- fasstr::compute_frequency_analysis(data = extremes, events = "Year", values = "Min_1_Day", use_max = FALSE, fit_quantiles = c(0.5, 0.2, 0.1, 0.05, 0.02, 0.01, 0.005, 0.002, 0.001, 0.0005))
          return_yrs <- c(min(lubridate::year(analysis$Freq_Analysis_Data$Min_1_Day_Date)), max(lubridate::year(analysis$Freq_Analysis_Data$Min_1_Day_Date)))
        }
        freq <- analysis$Freq_Fitted_Quantiles

        plot <- plot +
          ggplot2::geom_hline(yintercept = as.numeric(freq[10,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[9,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[8,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[7,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[6,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[5,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[4,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[3,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[2,4]), linetype = "dashed", color = "black") +
          ggplot2::geom_hline(yintercept = as.numeric(freq[1,4]), linetype = "dashed", color = "black") +
          ggplot2::annotate("text", x = mean(realtime$fake_datetime), y = c(as.numeric(freq[10,4]), as.numeric(freq[9,4]), as.numeric(freq[8,4]), as.numeric(freq[7,4]), as.numeric(freq[6,4]), as.numeric(freq[5,4]), as.numeric(freq[4,4]), as.numeric(freq[3,4]), as.numeric(freq[2,4]), as.numeric(freq[1,4])), label = if (language == "en") label_en else if (language == "fr") label_fr, size = 2.6*plot_scale, vjust = -.2*plot_scale)
      }, error = function(e) {
        returns <<- "failed"
      })
    }
  }
  #Add some information below the legend
  if (legend) {
    spread_vert <- max - min #Used to determine where to put the text
    # spreads_horz <- as.numeric(range(realtime$fake_datetime, na.rm = TRUE))
    # Calculate positions as a fraction of the data range
    # end_time1 <- as.POSIXct(spreads_horz[1] + (spreads_horz[2] - spreads_horz[1]))
    end_time1 <- max(realtime$fake_datetime, na.rm = TRUE)
    if (!is.infinite(minHist)) {
      if (overlaps) {
        if (language == "en") {
          line1 <- paste0("\n         \n        Historical range based\n        on years\n        ", ribbon_start_end[1], " to ", ribbon_start_end[2], "." )
        } else {
          line1 <- paste0("\n         \n        Plage historique bas\u00E9e\n        sur les ann\u00E9es\n        ", ribbon_start_end[1], " \u00E0 ", ribbon_start_end[2], "." )
        } 
      } else {
        if (language == "en") {
          line1 <- paste0("\n         \n        Historical range based\n        on years ", ribbon_start_end[1], " to ", ribbon_start_end[2], "." )
        } else {
          line1 <- paste0("\n         \n        Plage historique bas\u00E9e\n        sur les ann\u00E9es ", ribbon_start_end[1], " \u00E0 ", ribbon_start_end[2], "." )
        }
      }
    } else {
      if (language == "en") {
        line1 <- "\n         \n        Not enough data for\n        historical ranges"
      } else {
        line1 <- "\n         \n        Pas assez de donn\u00E9es pour\n        les plages historiques"
      }
      plot <- plot + #Adjust the legend spacing so that the text isn't pushed off the plot area
        ggplot2::theme(legend.box.spacing = ggplot2::unit(0, "pt"), legend.box.margin = ggplot2::margin(0, 0, 0, 0))
    }
    if (returns == "calculate") {
      if (language == "en") {
        line2 <- paste0("        \n        \n        Return periods calculated\n        using months ", month.abb[return_months[1]], " to ",  month.abb[return_months[length(return_months)]], " \n        and years ", return_yrs[1], " to ", return_yrs[2], ". \n        ", nrow(analysis$Freq_Analysis_Data), " data points retained after\n        removing years with > ", allowed_missing, " %\n        missing data.")
      } else {
        line2 <- paste0("        \n        \n        P\u00E9riodes de retour calcul\u00E9es\n        en utilisant les mois de ", format(ISOdate(2000, return_months[1], 1), "%b"), "\n        \u00E0 ",  format(ISOdate(2000, return_months[length(return_months)], 1), "%b"), " et les ann\u00E9es de ", return_yrs[1], "\n        \u00E0 ", return_yrs[2], ". ", nrow(analysis$Freq_Analysis_Data), " points de donn\u00E9es\n        conserv\u00E9s apr\u00E8s avoir retir\u00E9\n        les ann\u00E9es avec > ", allowed_missing, "% de\n        donn\u00E9es manquantes.")
      }
      lines <- paste0(line1, line2)
      plot <- plot +
        ggplot2::coord_cartesian(clip = "off", default = TRUE) +
        ggplot2::annotation_custom(grid::textGrob(lines, gp = grid::gpar(fontsize = 8 * plot_scale), just = "left"), xmin = end_time1, ymin = (max - spread_vert/2) - 7*spread_vert/30, ymax = (max - spread_vert/2) - 7*spread_vert/30)
    } else if (returns == "table") {
      if (language == "en") {
        line2 <- "        \n        \n        Return periods are based\n        on statistical analysis\n        of select data from the\n        start of records to 2021."
      } else {
        line2 <- "        \n        \n        P\u00E9riodes de retour bas\u00E9es\n        sur l'analyse statistique\n        de donn\u00E9es s\u00E9lectionn\u00E9es\n        depuis le d\u00E9but des enregistrements\n        jusqu'\u00E0 2021."
      }
      lines <- paste0(line1, line2)
      plot <- plot +
        ggplot2::coord_cartesian(clip = "off", default = TRUE) +
        ggplot2::annotation_custom(grid::textGrob(lines, gp = grid::gpar(fontsize = 8*plot_scale), just = "left"), xmin = end_time1, ymin = (max - spread_vert/2) - 7 * spread_vert/30, ymax = (max - spread_vert/2) - 7 * spread_vert/30)
    } else if (returns == "failed") {
      if (language == "en") {
        line2 <- "        \n        \n        Insufficient data to \n        calculate returns using\n        last requested year."
      } else {
        line2 <- "        \n        \n        Donn\u00E9es insuffisantes \n        pour calculer les p\u00E9riodes\n        de retour en utilisant\n        la derni\u00E8re ann\u00E9e demand\u00E9e."
      }
      lines <- paste0(line1, line2)
      plot <- plot +
        ggplot2::coord_cartesian(clip = "off", default = TRUE) +
        ggplot2::annotation_custom(grid::textGrob(lines, gp = grid::gpar(fontsize = 8*plot_scale), just = "left"), xmin = end_time1, ymin = (max - spread_vert/2) - 7 * spread_vert/30, ymax = (max - spread_vert/2) - 7 * spread_vert/30)
    } else {
      plot <- plot +
        ggplot2::coord_cartesian(clip = "off", default = TRUE) +
        ggplot2::annotation_custom(grid::textGrob(line1, gp = grid::gpar(fontsize = 8*plot_scale), just = "left"), xmin = end_time1, ymin = (max - spread_vert/2) - 7 * spread_vert/30, ymax = (max - spread_vert/2) - 7 * spread_vert/30)
    }
  }
  

  # Wrap things up and return() -----------------------
  if (title == TRUE) {
    if (is.null(custom_title) == TRUE) {
      if (language == "fr") {
        stn_name <- DBI::dbGetQuery(con, paste0("SELECT name_fr FROM locations where location = '", location, "'"))[1,1]
      } 
      if (language == "en" || is.na(stn_name) == TRUE) {
        stn_name <- DBI::dbGetQuery(con, paste0("SELECT name FROM locations where location = '", location, "'"))[1,1]
      }
      stn_name <- titleCase(stn_name, language)
      
      plot <- plot +
        ggplot2::labs(title = stn_name) +
        ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.05, size = 12*plot_scale, face = "bold"))
    } else if (is.null(custom_title) == FALSE) {
      plot <- plot +
        ggplot2::labs(title = as.character(custom_title)) +
        ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.05, size = 12*plot_scale, face = "bold"))
    }
  }

  #Save it if requested
  if (!is.null(save_path)) {
    ggplot2::ggsave(filename = paste0(save_path,"/", location, "_", parameter, "_", Sys.Date(), "_", lubridate::hour(as.POSIXct(format(Sys.time()), tz = tzone)), lubridate::minute(as.POSIXct(format(Sys.time()), tz = tzone)), ".png"), plot = plot, height = 8, width = 12, units = "in", device = "png", dpi = 500)
  }
  return(plot)
}


#' @rdname plotOverlap
#' @export
hydrometContinuous <- plotOverlap
